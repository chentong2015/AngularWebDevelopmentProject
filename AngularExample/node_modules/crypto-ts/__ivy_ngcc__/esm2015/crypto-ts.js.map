{"version":3,"file":"crypto-ts.js","sources":["../../src/enc/Hex.ts","../../src/lib/WordArray.ts","../../src/enc/Latin1.ts","../../src/enc/Utf8.ts","../../src/lib/BufferedBlockAlgorithm.ts","../../src/lib/Base.ts","../../src/lib/CipherParams.ts","../../src/enc/Base64.ts","../../src/format/OpenSSL.ts","../../src/lib/SerializableCipher.ts","../../src/lib/Hasher.ts","../../src/algo/MD5.ts","../../src/algo/EvpKDF.ts","../../src/kdf/OpenSSLKdf.ts","../../src/lib/PasswordBasedCipher.ts","../../src/lib/Cipher.ts","../../src/mode/BlockCipherModeAlgorithm.ts","../../src/mode/BlockCipherMode.ts","../../src/mode/CBCEncryptor.ts","../../src/mode/CBCDecryptor.ts","../../src/mode/CBC.ts","../../src/pad/PKCS7.ts","../../src/lib/BlockCipher.ts","../../src/algo/AES.ts","../../src/algo/SHA256.ts","../../src/pad/NoPadding.ts","../../src/mode/ECBEncryptor.ts","../../src/mode/ECBDecryptor.ts","../../src/mode/ECB.ts","../../src/crypto-ts.ts"],"names":["AESAlgorithm","SHA256Algorithm","AES","SHA256"],"mappings":"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,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QACQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QACQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QACQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,UAAU,EAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACvD,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE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","sourcesContent":["import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\n\nexport class Hex {\n    /**\n     * Converts a word array to a hex string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The hex string.\n     *\n     * @example\n     *\n     *     let hexString = Hex.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        // Convert\n        const hexChars: Array<string> = [];\n        for (let i = 0; i < wordArray.sigBytes; i++) {\n            const bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            hexChars.push((bite >>> 4).toString(16));\n            hexChars.push((bite & 0x0f).toString(16));\n        }\n\n        return hexChars.join('');\n    }\n\n    /**\n     * Converts a hex string to a word array.\n     *\n     * @param hexStr The hex string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Hex.parse(hexString);\n     */\n    public static parse(hexStr: string): WordArray {\n        // Shortcut\n        const hexStrLength = hexStr.length;\n\n        // Convert\n        const words: Array<number> = [];\n        for (let i = 0; i < hexStrLength; i += 2) {\n            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n        }\n\n        return new WordArray(words, hexStrLength / 2);\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Hex;","import { Encoding } from '../enc/Encoding';\nimport { Hex } from '../enc/Hex';\n\nexport class WordArray {\n    words: Array<number>;\n\n    sigBytes: number;\n\n    /**\n     * Creates a word array filled with random bytes.\n     *\n     * @param nBytes The number of random bytes to generate.\n     *\n     * @return The random word array.\n     *\n     * @example\n     *\n     *     let wordArray = WordArray.random(16);\n     */\n    public static random(nBytes: number) {\n        const words = [];\n\n        const r = (function(m_w: number) {\n            let m_z = 0x3ade68b1;\n\n            const mask = 0xffffffff;\n\n            return function() {\n                m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n                m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n                let result = ((m_z << 0x10) + m_w) & mask;\n                result /= 0x100000000;\n                result += 0.5;\n                return result * (Math.random() > .5 ? 1 : -1);\n            };\n        });\n\n        for(let i = 0, rcache; i < nBytes; i += 4) {\n            const _r = r((rcache || Math.random()) * 0x100000000);\n\n            rcache = _r() * 0x3ade67b7;\n            words.push((_r() * 0x100000000) | 0);\n        }\n\n        return new WordArray(words, nBytes);\n    }\n\n    /**\n     * Initializes a newly created word array.\n     *\n     * @param words (Optional) An array of 32-bit words.\n     * @param sigBytes (Optional) The number of significant bytes in the words.\n     *\n     * @example\n     *\n     *     let wordArray = new WordArray();\n     *     let wordArray = new WordArray([0x00010203, 0x04050607]);\n     *     let wordArray = new WordArray([0x00010203, 0x04050607], 6);\n     */\n    constructor(words?: Array<number>, sigBytes?: number) {\n        this.words = words || [];\n\n        if(sigBytes !== undefined) {\n            this.sigBytes = sigBytes;\n        } else {\n            this.sigBytes = this.words.length * 4;\n        }\n    }\n\n    /**\n     * Converts this word array to a string.\n     *\n     * @param encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n     *\n     * @return The stringified word array.\n     *\n     * @example\n     *\n     *     let string = wordArray + '';\n     *     let string = wordArray.toString();\n     *     let string = wordArray.toString(CryptoJS.enc.Utf8);\n     */\n    toString(encoder?: Encoding): string {\n        return (encoder || Hex).stringify(this);\n    }\n\n    /**\n     * Concatenates a word array to this word array.\n     *\n     * @param wordArray The word array to append.\n     *\n     * @return This word array.\n     *\n     * @example\n     *\n     *     wordArray1.concat(wordArray2);\n     */\n    concat(wordArray: WordArray): WordArray {\n        // Clamp excess bits\n        this.clamp();\n\n        // Concat\n        if(this.sigBytes % 4) {\n            // Copy one byte at a time\n            for(let i = 0; i < wordArray.sigBytes; i++) {\n                const thatByte = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                this.words[(this.sigBytes + i) >>> 2] |= thatByte << (24 - ((this.sigBytes + i) % 4) * 8);\n            }\n        } else {\n            // Copy one word at a time\n            for (let i = 0; i < wordArray.sigBytes; i += 4) {\n                this.words[(this.sigBytes + i) >>> 2] = wordArray.words[i >>> 2];\n            }\n        }\n        this.sigBytes += wordArray.sigBytes;\n\n        // Chainable\n        return this;\n    }\n\n    /**\n     * Removes insignificant bits.\n     *\n     * @example\n     *\n     *     wordArray.clamp();\n     */\n    clamp() {\n        // Clamp\n        this.words[this.sigBytes >>> 2] &= 0xffffffff << (32 - (this.sigBytes % 4) * 8);\n        this.words.length = Math.ceil(this.sigBytes / 4);\n    }\n\n    /**\n     * Creates a copy of this word array.\n     *\n     * @return The clone.\n     *\n     * @example\n     *\n     *     let clone = wordArray.clone();\n     */\n    clone(): WordArray {\n        return new WordArray(this.words.slice(0), this.sigBytes);\n    }\n}","import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\n\ndeclare function escape(s: string): string;\ndeclare function unescape(s: string): string;\n\nexport class Latin1 {\n    /**\n     * Converts a word array to a Latin1 string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The Latin1 string.\n     *\n     * @example\n     *\n     *     let latin1String = Latin1.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        // Convert\n        const latin1Chars = [];\n        for (let i = 0; i < wordArray.sigBytes; i++) {\n            const bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            latin1Chars.push(String.fromCharCode(bite));\n        }\n\n        return latin1Chars.join('');\n    }\n\n    /**\n     * Converts a Latin1 string to a word array.\n     *\n     * @param latin1Str The Latin1 string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Latin1.parse(latin1String);\n     */\n    public static parse(latin1Str: string): WordArray {\n        // Shortcut\n        const latin1StrLength = latin1Str.length;\n\n        // Convert\n        const words: Array<number> = [];\n        for (let i = 0; i < latin1StrLength; i++) {\n            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n        }\n\n        return new WordArray(words, latin1StrLength);\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Latin1;","import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\nimport { Latin1 } from './Latin1';\n\nexport class Utf8 {\n    /**\n     * Converts a word array to a UTF-8 string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The UTF-8 string.\n     *\n     * @example\n     *\n     *     let utf8String = Utf8.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        try {\n            return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n        } catch(e) {\n            throw new Error('Malformed UTF-8 data');\n        }\n    }\n\n    /**\n     * Converts a UTF-8 string to a word array.\n     *\n     * @param utf8Str The UTF-8 string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Utf8.parse(utf8String);\n     */\n    public static parse(utf8Str: string): WordArray {\n        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Utf8;","import { WordArray } from '../lib/WordArray';\nimport { Utf8 } from '../enc/Utf8';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\n\nexport abstract class BufferedBlockAlgorithm {\n    public _minBufferSize = 0;\n\n    public _data: WordArray;\n\n    public _nDataBytes: number;\n\n    public cfg: BufferedBlockAlgorithmConfig;\n\n    abstract _doProcessBlock(wordArray: Array<number>, offset: number): void;\n\n    constructor(cfg?: BufferedBlockAlgorithmConfig) {\n        this.cfg = Object.assign({\n            blockSize: 1\n        }, cfg);\n\n        // Initial values\n        this._data = new WordArray();\n        this._nDataBytes = 0;\n    }\n\n    /**\n     * Resets this block algorithm's data buffer to its initial state.\n     *\n     * @example\n     *\n     *     bufferedBlockAlgorithm.reset();\n     */\n    reset() {\n        // Initial values\n        this._data = new WordArray();\n        this._nDataBytes = 0;\n    }\n\n    /**\n     * Adds new data to this block algorithm's buffer.\n     *\n     * @param data The data to append. Strings are converted to a WordArray using UTF-8.\n     *\n     * @example\n     *\n     *     bufferedBlockAlgorithm._append('data');\n     *     bufferedBlockAlgorithm._append(wordArray);\n     */\n    _append(data: string | WordArray) {\n        // Convert string to WordArray, else assume WordArray already\n        if(typeof data === 'string') {\n            data = Utf8.parse(data);\n        }\n\n        // Append\n        this._data.concat(data);\n        this._nDataBytes += data.sigBytes;\n    }\n\n    /**\n     * Processes available data blocks.\n     *\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n     *\n     * @param doFlush Whether all blocks and partial blocks should be processed.\n     *\n     * @return The processed data.\n     *\n     * @example\n     *\n     *     let processedData = bufferedBlockAlgorithm._process();\n     *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\n     */\n    _process(doFlush?: boolean): WordArray {\n        if(!this.cfg.blockSize) {\n            throw new Error('missing blockSize in config');\n        }\n\n        // Shortcuts\n        const blockSizeBytes = this.cfg.blockSize * 4;\n\n        // Count blocks ready\n        let nBlocksReady = this._data.sigBytes / blockSizeBytes;\n        if (doFlush) {\n            // Round up to include partial blocks\n            nBlocksReady = Math.ceil(nBlocksReady);\n        } else {\n            // Round down to include only full blocks,\n            // less the number of blocks that must remain in the buffer\n            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n        }\n\n        // Count words ready\n        const nWordsReady = nBlocksReady * this.cfg.blockSize;\n\n        // Count bytes ready\n        const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n\n        // Process blocks\n        let processedWords;\n        if (nWordsReady) {\n            for (let offset = 0; offset < nWordsReady; offset += this.cfg.blockSize) {\n                // Perform concrete-algorithm logic\n                this._doProcessBlock(this._data.words, offset);\n            }\n\n            // Remove processed words\n            processedWords = this._data.words.splice(0, nWordsReady);\n            this._data.sigBytes -= nBytesReady;\n        }\n\n        // Return processed words\n        return new WordArray(processedWords, nBytesReady);\n    }\n\n    /**\n     * Creates a copy of this object.\n     *\n     * @return The clone.\n     *\n     * @example\n     *\n     *     let clone = bufferedBlockAlgorithm.clone();\n     */\n    clone(): BufferedBlockAlgorithm {\n        const clone = this.constructor();\n\n        for(const attr in this) {\n            if(this.hasOwnProperty(attr)) {\n                clone[attr] = this[attr];\n            }\n        }\n\n        clone._data = this._data.clone();\n\n        return clone;\n    }\n}","export class Base {\n}","import { Base } from '../lib/Base';\nimport { CipherParamsInterface } from './CipherParamsInterface';\nimport { WordArray } from '../lib/WordArray';\nimport { Cipher } from '../lib/Cipher';\nimport { BlockCipherMode } from '../mode/BlockCipherMode';\nimport { Padding } from '../pad/Padding';\nimport { Formatter } from '../format/Formatter';\n\nexport class CipherParams extends Base implements CipherParamsInterface {\n    ciphertext?: WordArray;\n\n    key?: WordArray | string;\n\n    iv?: WordArray;\n\n    salt?: WordArray | string;\n\n    algorithm?: typeof Cipher;\n\n    mode?: typeof BlockCipherMode;\n\n    padding?: Padding;\n\n    blockSize?: number;\n\n    formatter?: Formatter;\n\n    /**\n     * Initializes a newly created cipher params object.\n     *\n     * @param cipherParams An object with any of the possible cipher parameters.\n     *\n     * @example\n     *\n     *     let cipherParams = CipherParams.create({\n     *         ciphertext: ciphertextWordArray,\n     *         key: keyWordArray,\n     *         iv: ivWordArray,\n     *         salt: saltWordArray,\n     *         algorithm: AESAlgorithm,\n     *         mode: CBC,\n     *         padding: PKCS7,\n     *         blockSize: 4,\n     *         formatter: OpenSSLFormatter\n     *     });\n     */\n    public constructor(cipherParams: CipherParamsInterface) {\n        super();\n\n        this.ciphertext = cipherParams.ciphertext;\n        this.key = cipherParams.key;\n        this.iv = cipherParams.iv;\n        this.salt = cipherParams.salt;\n        this.algorithm = cipherParams.algorithm;\n        this.mode = cipherParams.mode;\n        this.padding = cipherParams.padding;\n        this.blockSize = cipherParams.blockSize;\n        this.formatter = cipherParams.formatter;\n    }\n\n    public extend(additionalParams: CipherParams): CipherParams {\n        if(additionalParams.ciphertext !== undefined) {\n            this.ciphertext = additionalParams.ciphertext;\n        }\n\n        if(additionalParams.key !== undefined) {\n            this.key = additionalParams.key;\n        }\n\n        if(additionalParams.iv !== undefined) {\n            this.iv = additionalParams.iv;\n        }\n\n        if(additionalParams.salt !== undefined) {\n            this.salt = additionalParams.salt;\n        }\n\n        if(additionalParams.algorithm !== undefined) {\n            this.algorithm = additionalParams.algorithm;\n        }\n\n        if(additionalParams.mode !== undefined) {\n            this.mode = additionalParams.mode;\n        }\n\n        if(additionalParams.padding !== undefined) {\n            this.padding = additionalParams.padding;\n        }\n\n        if(additionalParams.blockSize !== undefined) {\n            this.blockSize = additionalParams.blockSize;\n        }\n\n        if(additionalParams.formatter !== undefined) {\n            this.formatter = additionalParams.formatter;\n        }\n\n\n        return this;\n    }\n\n    /**\n     * Converts this cipher params object to a string.\n     *\n     * @param formatter (Optional) The formatting strategy to use.\n     *\n     * @return The stringified cipher params.\n     *\n     * @throws Error If neither the formatter nor the default formatter is set.\n     *\n     * @example\n     *\n     *     let string = cipherParams + '';\n     *     let string = cipherParams.toString();\n     *     let string = cipherParams.toString(CryptoJS.format.OpenSSL);\n     */\n    public toString(formatter?: Formatter): string {\n        if(formatter) {\n            return formatter.stringify(this);\n        } else if(this.formatter) {\n            return this.formatter.stringify(this);\n        } else {\n            throw new Error('cipher needs a formatter to be able to convert the result into a string');\n        }\n    }\n}","import { Encoding } from './Encoding';\nimport { WordArray } from '../lib/WordArray';\n\nexport class Base64 {\n    public static _map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n    public static _reverseMap: Array<number> | undefined = undefined;\n\n    /**\n     * Converts a word array to a Base64 string.\n     *\n     * @param wordArray The word array.\n     *\n     * @return The Base64 string.\n     *\n     * @example\n     *\n     *     let base64String = Base64.stringify(wordArray);\n     */\n    public static stringify(wordArray: WordArray): string {\n        // Clamp excess bits\n        wordArray.clamp();\n\n        // Convert\n        const base64Chars = [];\n        for (let i = 0; i < wordArray.sigBytes; i += 3) {\n            const byte1 = (wordArray.words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n            const byte2 = (wordArray.words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n            const byte3 = (wordArray.words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n            const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n            for (let j = 0; (j < 4) && (i + j * 0.75 < wordArray.sigBytes); j++) {\n                base64Chars.push(this._map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n            }\n        }\n\n        // Add padding\n        const paddingChar = this._map.charAt(64);\n        if (paddingChar) {\n            while (base64Chars.length % 4) {\n                base64Chars.push(paddingChar);\n            }\n        }\n\n        return base64Chars.join('');\n    }\n\n    /**\n     * Converts a Base64 string to a word array.\n     *\n     * @param base64Str The Base64 string.\n     *\n     * @return The word array.\n     *\n     * @example\n     *\n     *     let wordArray = Base64.parse(base64String);\n     */\n    public static parse(base64Str: string): WordArray {\n        // Shortcuts\n        let base64StrLength = base64Str.length;\n\n        if(this._reverseMap === undefined) {\n                this._reverseMap = [];\n                for(let j = 0; j < this._map.length; j++) {\n                    this._reverseMap[this._map.charCodeAt(j)] = j;\n                }\n        }\n\n        // Ignore padding\n        const paddingChar = this._map.charAt(64);\n        if(paddingChar) {\n            const paddingIndex = base64Str.indexOf(paddingChar);\n            if(paddingIndex !== -1) {\n                base64StrLength = paddingIndex;\n            }\n        }\n\n        // Convert\n        return this.parseLoop(base64Str, base64StrLength, this._reverseMap);\n    }\n\n    public static parseLoop(base64Str: string, base64StrLength: number, reverseMap: Array<number>): WordArray {\n        const words: Array<number> = [];\n        let nBytes = 0;\n        for(let i = 0; i < base64StrLength; i++) {\n            if(i % 4) {\n                const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n                const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n                words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);\n                nBytes++;\n            }\n        }\n\n        return new WordArray(words, nBytes);\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Encoding = Base64;","import { Formatter } from './Formatter';\nimport { CipherParams } from '../lib/CipherParams';\nimport { WordArray } from '../lib/WordArray';\nimport { Base64 } from '../enc/Base64';\n\nexport class OpenSSL {\n    /**\n     * Converts a cipher params object to an OpenSSL-compatible string.\n     *\n     * @param cipherParams The cipher params object.\n     *\n     * @return The OpenSSL-compatible string.\n     *\n     * @example\n     *\n     *     let openSSLString = OpenSSLFormatter.stringify(cipherParams);\n     */\n    public static stringify(cipherParams: CipherParams): string {\n        if(!cipherParams.ciphertext) {\n            throw new Error('missing ciphertext in params');\n        }\n\n        // Shortcuts\n        const ciphertext = cipherParams.ciphertext;\n        const salt = cipherParams.salt;\n\n        // Format\n        let wordArray: WordArray;\n        if(salt) {\n            if(typeof salt === 'string') {\n                throw new Error('salt is expected to be a WordArray');\n            }\n\n            wordArray = (new WordArray([0x53616c74, 0x65645f5f])).concat(salt).concat(ciphertext);\n        } else {\n            wordArray = ciphertext;\n        }\n\n        return wordArray.toString(Base64);\n    }\n\n    /**\n     * Converts an OpenSSL-compatible string to a cipher params object.\n     *\n     * @param openSSLStr The OpenSSL-compatible string.\n     *\n     * @return The cipher params object.\n     *\n     * @example\n     *\n     *     let cipherParams = OpenSSLFormatter.parse(openSSLString);\n     */\n    public static parse(openSSLStr: string): CipherParams {\n        // Parse base64\n        const ciphertext = Base64.parse(openSSLStr);\n\n        // Test for salt\n        let salt: WordArray | undefined;\n        if(ciphertext.words[0] === 0x53616c74 && ciphertext.words[1] === 0x65645f5f) {\n            // Extract salt\n            salt = new WordArray(ciphertext.words.slice(2, 4));\n\n            // Remove salt from ciphertext\n            ciphertext.words.splice(0, 4);\n            ciphertext.sigBytes -= 16;\n        }\n\n        return new CipherParams({ ciphertext: ciphertext, salt: salt });\n    }\n}\n\n// type guard for OpenSSL formatter (to ensure it has the required static methods)\nconst _: Formatter = OpenSSL;","import { WordArray } from './WordArray';\nimport { Cipher } from './Cipher';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { OpenSSL } from '../format/OpenSSL';\nimport { CipherParams } from './CipherParams';\nimport { Formatter } from '../format/Formatter';\n\nexport class SerializableCipher {\n    public static cfg: BufferedBlockAlgorithmConfig = {\n        blockSize: 4,\n        iv: new WordArray([]),\n        format: OpenSSL\n    };\n\n    /**\n     * Encrypts a message.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param message The message to encrypt.\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher params object.\n     *\n     * @example\n     *\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, {\n     *       iv: iv,\n     *       format: CryptoJS.format.OpenSSL\n     *     });\n     */\n    public static encrypt(\n        cipher: typeof Cipher,\n        message: WordArray | string,\n        key: WordArray,\n        cfg?: BufferedBlockAlgorithmConfig\n    ): CipherParams {\n        // Apply config defaults\n        const config = Object.assign({}, this.cfg, cfg);\n\n        // Encrypt\n        const encryptor = cipher.createEncryptor(key, config);\n        const ciphertext = encryptor.finalize(message);\n\n        // Create and return serializable cipher params\n        return new CipherParams({\n            ciphertext: ciphertext,\n            key: key,\n            iv: encryptor.cfg.iv,\n            algorithm: cipher,\n            mode: (<any> encryptor.cfg).mode,\n            padding: (<any> encryptor.cfg).padding,\n            blockSize: encryptor.cfg.blockSize,\n            formatter: config.format\n        });\n    }\n\n    /**\n     * Decrypts serialized ciphertext.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param ciphertext The ciphertext to decrypt.\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return The plaintext.\n     *\n     * @example\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         formattedCiphertext,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         ciphertextParams,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     */\n    public static decrypt(\n        cipher: typeof Cipher,\n        ciphertext: CipherParams | string,\n        key: WordArray,\n        optionalCfg?: BufferedBlockAlgorithmConfig\n    ): WordArray {\n        // Apply config defaults\n        const cfg = Object.assign({}, this.cfg, optionalCfg);\n\n        if(!cfg.format) {\n            throw new Error('could not determine format');\n        }\n\n        // Convert string to CipherParams\n        ciphertext = this._parse(ciphertext, cfg.format);\n\n        if(!ciphertext.ciphertext) {\n            throw new Error('could not determine ciphertext');\n        }\n\n        // Decrypt\n        const plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n        return plaintext;\n    }\n\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * @param ciphertext The ciphertext.\n     * @param format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return The unserialized ciphertext.\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     */\n    public static _parse(ciphertext: CipherParams | string, format: Formatter): CipherParams {\n        if(typeof ciphertext === 'string') {\n            return format.parse(ciphertext);\n        } else {\n            return ciphertext;\n        }\n    }\n}","import { BufferedBlockAlgorithm } from '../lib/BufferedBlockAlgorithm';\nimport { BufferedBlockAlgorithmConfig } from '../lib/BufferedBlockAlgorithmConfig';\nimport { WordArray } from '../lib/WordArray';\n\nexport abstract class Hasher extends BufferedBlockAlgorithm {\n    /**\n     * Creates a shortcut function to a hasher's object interface.\n     *\n     * @param hasher The hasher to create a helper for.\n     *\n     * @return The shortcut function.\n     *\n     * @example\n     *\n     *     let SHA256 = Hasher._createHelper(SHA256);\n     */\n    public static _createHelper(hasher: typeof Hasher) {\n        function helper(message: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\n            const hasherClass: any = hasher;\n\n            const hasherInstance: any = new hasherClass(cfg);\n\n            return hasherInstance.finalize(message);\n        }\n\n        return helper;\n    }\n\n    /**\n     * Initializes a newly created hasher.\n     *\n     * @param cfg (Optional) The configuration options to use for this hash computation.\n     *\n     * @example\n     *\n     *     let hasher = CryptoJS.algo.SHA256.create();\n     */\n    public constructor(cfg?: BufferedBlockAlgorithmConfig) {\n        // Apply config defaults\n        super(Object.assign({\n            blockSize: 512 / 32\n        }, cfg));\n\n        // Set initial values\n        this.reset();\n    }\n\n    /**\n     * Updates this hasher with a message.\n     *\n     * @param messageUpdate The message to append.\n     *\n     * @return This hasher.\n     *\n     * @example\n     *\n     *     hasher.update('message');\n     *     hasher.update(wordArray);\n     */\n    update(messageUpdate: WordArray | string): Hasher {\n        // Append\n        this._append(messageUpdate);\n\n        // Update the hash\n        this._process();\n\n        // Chainable\n        return this;\n    }\n\n    /**\n     * Finalizes the hash computation.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * @param messageUpdate (Optional) A final message update.\n     *\n     * @return The hash.\n     *\n     * @example\n     *\n     *     let hash = hasher.finalize();\n     *     let hash = hasher.finalize('message');\n     *     let hash = hasher.finalize(wordArray);\n     */\n    public finalize(messageUpdate: WordArray | string): WordArray {\n        // Final message update\n        if(messageUpdate) {\n            this._append(messageUpdate);\n        }\n\n        // Perform concrete-hasher logic\n        const hash = this._doFinalize();\n\n        return hash;\n    }\n\n    public abstract _doFinalize(): WordArray;\n}","import { Hasher } from '../lib/Hasher';\nimport { WordArray } from '../lib/WordArray';\n\n// Constants table\nconst T: Array<number> = [];\n\n// Compute constants\nfor(let i = 0; i < 64; i++) {\n    T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\n\nexport class MD5 extends Hasher {\n    public _hash!: WordArray;\n\n    public static FF(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + ((b & c) | (~b & d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public static GG(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + ((b & d) | (c & ~d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public static HH(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + (b ^ c ^ d) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public static II(a: number, b: number, c: number, d: number, x: number, s: number, t: number): number {\n        const n = a + (c ^ (b | ~d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    }\n\n    public reset() {\n        // reset core values\n        super.reset();\n\n        this._hash = new WordArray([\n            0x67452301, 0xefcdab89,\n            0x98badcfe, 0x10325476\n        ]);\n    }\n\n    public _doProcessBlock(M: Array<number>, offset: number) {\n        // Swap endian\n        for(let i = 0; i < 16; i++) {\n            // Shortcuts\n            const offset_i = offset + i;\n            const M_offset_i = M[offset_i];\n\n            M[offset_i] = (\n                (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n                (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n            );\n        }\n\n        // Shortcuts\n        const H = this._hash.words;\n\n        const M_offset_0  = M[offset + 0];\n        const M_offset_1  = M[offset + 1];\n        const M_offset_2  = M[offset + 2];\n        const M_offset_3  = M[offset + 3];\n        const M_offset_4  = M[offset + 4];\n        const M_offset_5  = M[offset + 5];\n        const M_offset_6  = M[offset + 6];\n        const M_offset_7  = M[offset + 7];\n        const M_offset_8  = M[offset + 8];\n        const M_offset_9  = M[offset + 9];\n        const M_offset_10 = M[offset + 10];\n        const M_offset_11 = M[offset + 11];\n        const M_offset_12 = M[offset + 12];\n        const M_offset_13 = M[offset + 13];\n        const M_offset_14 = M[offset + 14];\n        const M_offset_15 = M[offset + 15];\n\n        // Working variables\n        let a = H[0];\n        let b = H[1];\n        let c = H[2];\n        let d = H[3];\n\n        // Computation\n        a = MD5.FF(a, b, c, d, M_offset_0,  7,  T[0]);\n        d = MD5.FF(d, a, b, c, M_offset_1,  12, T[1]);\n        c = MD5.FF(c, d, a, b, M_offset_2,  17, T[2]);\n        b = MD5.FF(b, c, d, a, M_offset_3,  22, T[3]);\n        a = MD5.FF(a, b, c, d, M_offset_4,  7,  T[4]);\n        d = MD5.FF(d, a, b, c, M_offset_5,  12, T[5]);\n        c = MD5.FF(c, d, a, b, M_offset_6,  17, T[6]);\n        b = MD5.FF(b, c, d, a, M_offset_7,  22, T[7]);\n        a = MD5.FF(a, b, c, d, M_offset_8,  7,  T[8]);\n        d = MD5.FF(d, a, b, c, M_offset_9,  12, T[9]);\n        c = MD5.FF(c, d, a, b, M_offset_10, 17, T[10]);\n        b = MD5.FF(b, c, d, a, M_offset_11, 22, T[11]);\n        a = MD5.FF(a, b, c, d, M_offset_12, 7,  T[12]);\n        d = MD5.FF(d, a, b, c, M_offset_13, 12, T[13]);\n        c = MD5.FF(c, d, a, b, M_offset_14, 17, T[14]);\n        b = MD5.FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n        a = MD5.GG(a, b, c, d, M_offset_1,  5,  T[16]);\n        d = MD5.GG(d, a, b, c, M_offset_6,  9,  T[17]);\n        c = MD5.GG(c, d, a, b, M_offset_11, 14, T[18]);\n        b = MD5.GG(b, c, d, a, M_offset_0,  20, T[19]);\n        a = MD5.GG(a, b, c, d, M_offset_5,  5,  T[20]);\n        d = MD5.GG(d, a, b, c, M_offset_10, 9,  T[21]);\n        c = MD5.GG(c, d, a, b, M_offset_15, 14, T[22]);\n        b = MD5.GG(b, c, d, a, M_offset_4,  20, T[23]);\n        a = MD5.GG(a, b, c, d, M_offset_9,  5,  T[24]);\n        d = MD5.GG(d, a, b, c, M_offset_14, 9,  T[25]);\n        c = MD5.GG(c, d, a, b, M_offset_3,  14, T[26]);\n        b = MD5.GG(b, c, d, a, M_offset_8,  20, T[27]);\n        a = MD5.GG(a, b, c, d, M_offset_13, 5,  T[28]);\n        d = MD5.GG(d, a, b, c, M_offset_2,  9,  T[29]);\n        c = MD5.GG(c, d, a, b, M_offset_7,  14, T[30]);\n        b = MD5.GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n        a = MD5.HH(a, b, c, d, M_offset_5,  4,  T[32]);\n        d = MD5.HH(d, a, b, c, M_offset_8,  11, T[33]);\n        c = MD5.HH(c, d, a, b, M_offset_11, 16, T[34]);\n        b = MD5.HH(b, c, d, a, M_offset_14, 23, T[35]);\n        a = MD5.HH(a, b, c, d, M_offset_1,  4,  T[36]);\n        d = MD5.HH(d, a, b, c, M_offset_4,  11, T[37]);\n        c = MD5.HH(c, d, a, b, M_offset_7,  16, T[38]);\n        b = MD5.HH(b, c, d, a, M_offset_10, 23, T[39]);\n        a = MD5.HH(a, b, c, d, M_offset_13, 4,  T[40]);\n        d = MD5.HH(d, a, b, c, M_offset_0,  11, T[41]);\n        c = MD5.HH(c, d, a, b, M_offset_3,  16, T[42]);\n        b = MD5.HH(b, c, d, a, M_offset_6,  23, T[43]);\n        a = MD5.HH(a, b, c, d, M_offset_9,  4,  T[44]);\n        d = MD5.HH(d, a, b, c, M_offset_12, 11, T[45]);\n        c = MD5.HH(c, d, a, b, M_offset_15, 16, T[46]);\n        b = MD5.HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n        a = MD5.II(a, b, c, d, M_offset_0,  6,  T[48]);\n        d = MD5.II(d, a, b, c, M_offset_7,  10, T[49]);\n        c = MD5.II(c, d, a, b, M_offset_14, 15, T[50]);\n        b = MD5.II(b, c, d, a, M_offset_5,  21, T[51]);\n        a = MD5.II(a, b, c, d, M_offset_12, 6,  T[52]);\n        d = MD5.II(d, a, b, c, M_offset_3,  10, T[53]);\n        c = MD5.II(c, d, a, b, M_offset_10, 15, T[54]);\n        b = MD5.II(b, c, d, a, M_offset_1,  21, T[55]);\n        a = MD5.II(a, b, c, d, M_offset_8,  6,  T[56]);\n        d = MD5.II(d, a, b, c, M_offset_15, 10, T[57]);\n        c = MD5.II(c, d, a, b, M_offset_6,  15, T[58]);\n        b = MD5.II(b, c, d, a, M_offset_13, 21, T[59]);\n        a = MD5.II(a, b, c, d, M_offset_4,  6,  T[60]);\n        d = MD5.II(d, a, b, c, M_offset_11, 10, T[61]);\n        c = MD5.II(c, d, a, b, M_offset_2,  15, T[62]);\n        b = MD5.II(b, c, d, a, M_offset_9,  21, T[63]);\n\n        // Intermediate hash value\n        H[0] = (H[0] + a) | 0;\n        H[1] = (H[1] + b) | 0;\n        H[2] = (H[2] + c) | 0;\n        H[3] = (H[3] + d) | 0;\n    }\n\n    public _doFinalize(): WordArray {\n        // Shortcuts\n        const data = this._data;\n        const dataWords = data.words;\n\n        const nBitsTotal = this._nDataBytes * 8;\n        const nBitsLeft = data.sigBytes * 8;\n\n        // Add padding\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n        const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n        const nBitsTotalL = nBitsTotal;\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n            (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n        );\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n            (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n        );\n\n        data.sigBytes = (dataWords.length + 1) * 4;\n\n        // Hash final blocks\n        this._process();\n\n        // Shortcuts\n        const hash = this._hash;\n        const H = hash.words;\n\n        // Swap endian\n        for (let i = 0; i < 4; i++) {\n            // Shortcut\n            const H_i = H[i];\n\n            H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n                   (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n        }\n\n        // Return final computed hash\n        return hash;\n    }\n}","import { WordArray } from '../lib/WordArray';\nimport { Hasher } from '../lib/Hasher';\nimport { MD5 } from '../algo/MD5';\n\nexport interface OptionalEvpKDFConfig {\n    keySize?: number;\n    hasher?: typeof Hasher;\n    iterations?: number;\n}\n\nexport interface EvpKDFConfig extends OptionalEvpKDFConfig {\n    keySize: number;\n    hasher: typeof Hasher;\n    iterations: number;\n}\n\nexport class EvpKDF {\n    public cfg: EvpKDFConfig;\n\n    /**\n     * Initializes a newly created key derivation function.\n     *\n     * @param cfg (Optional) The configuration options to use for the derivation.\n     *\n     * @example\n     *\n     *     let kdf = EvpKDF.create();\n     *     let kdf = EvpKDF.create({ keySize: 8 });\n     *     let kdf = EvpKDF.create({ keySize: 8, iterations: 1000 });\n     */\n    constructor(cfg?: OptionalEvpKDFConfig) {\n        this.cfg = Object.assign({\n            keySize: 128 / 32,\n            hasher: MD5,\n            iterations: 1\n        }, cfg);\n    }\n\n    /**\n     * Derives a key from a password.\n     *\n     * @param password The password.\n     * @param salt A salt.\n     *\n     * @return The derived key.\n     *\n     * @example\n     *\n     *     let key = kdf.compute(password, salt);\n     */\n    compute(password: WordArray | string, salt: WordArray | string): WordArray {\n        // Init hasher\n        const hasher = new (<any> this.cfg.hasher)();\n\n        // Initial values\n        const derivedKey = new WordArray();\n\n        // Generate key\n        let block;\n        while(derivedKey.words.length < this.cfg.keySize) {\n            if(block) {\n                hasher.update(block);\n            }\n            block = hasher.update(password).finalize(salt);\n            hasher.reset();\n\n            // Iterations\n            for(let i = 1; i < this.cfg.iterations; i++) {\n                block = hasher.finalize(block);\n                hasher.reset();\n            }\n\n            derivedKey.concat(block);\n        }\n        derivedKey.sigBytes = this.cfg.keySize * 4;\n\n        return derivedKey;\n    }\n}","import { KDF } from './KDF';\nimport { WordArray } from '../lib/WordArray';\nimport { CipherParams } from '../lib/CipherParams';\nimport { EvpKDF } from '../algo/EvpKDF';\n\nexport class OpenSSLKdf {\n    /**\n     * Derives a key and IV from a password.\n     *\n     * @param password The password to derive from.\n     * @param keySize The size in words of the key to generate.\n     * @param ivSize The size in words of the IV to generate.\n     * @param salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n     *\n     * @return A cipher params object with the key, IV, and salt.\n     *\n     * @example\n     *\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32);\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n     */\n    public static execute(password: string, keySize: number, ivSize: number, salt?: WordArray | string): CipherParams {\n        // Generate random salt\n        if(!salt) {\n            salt = WordArray.random(64 / 8);\n        }\n\n        // Derive key and IV\n        const key = (new EvpKDF({ keySize: keySize + ivSize })).compute(password, salt);\n\n        // Separate key and IV\n        const iv = new WordArray(key.words.slice(keySize), ivSize * 4);\n        key.sigBytes = keySize * 4;\n\n        // Return params\n        return new CipherParams({ key: key, iv: iv, salt: salt });\n    }\n}\n\nconst _: KDF = OpenSSLKdf;","import { SerializableCipher } from './SerializableCipher';\nimport { WordArray } from './WordArray';\nimport { Cipher } from './Cipher';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { OpenSSL } from '../format/OpenSSL';\nimport { CipherParams } from './CipherParams';\nimport { Formatter } from '../format/Formatter';\nimport { OpenSSLKdf } from '../kdf/OpenSSLKdf';\n\nexport class PasswordBasedCipher {\n    public static cfg: BufferedBlockAlgorithmConfig = {\n        blockSize: 4,\n        iv: new WordArray([]),\n        format: OpenSSL,\n        kdf: OpenSSLKdf\n    };\n\n    /**\n     * Encrypts a message using a password.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param message The message to encrypt.\n     * @param password The password.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher params object.\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password');\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password', { format: OpenSSL });\n     */\n    public static encrypt(\n        cipher: typeof Cipher,\n        message: WordArray | string,\n        password: string,\n        cfg?: BufferedBlockAlgorithmConfig\n    ): CipherParams {\n        // Apply config defaults\n        const config = Object.assign({}, this.cfg, cfg);\n\n        // Check if we have a kdf\n        if(config.kdf === undefined) {\n            throw new Error('missing kdf in config');\n        }\n\n        // Derive key and other params\n        const derivedParams: CipherParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n        // Check if we have an IV\n        if(derivedParams.iv !== undefined) {\n            // Add IV to config\n            config.iv = derivedParams.iv;\n        }\n\n        // Encrypt\n        const ciphertext: CipherParams = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, config);\n\n        // Mix in derived params\n        return ciphertext.extend(derivedParams);\n    }\n\n    /**\n     * Decrypts serialized ciphertext using a password.\n     *\n     * @param cipher The cipher algorithm to use.\n     * @param ciphertext The ciphertext to decrypt.\n     * @param password The password.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return The plaintext.\n     *\n     * @example\n     *\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, formattedCiphertext, 'password', { format: OpenSSL });\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, ciphertextParams, 'password', { format: OpenSSL });\n     */\n    public static decrypt(\n        cipher: typeof Cipher,\n        ciphertext: CipherParams | string,\n        password: string,\n        cfg?: BufferedBlockAlgorithmConfig\n    ): WordArray {\n        // Apply config defaults\n        const config = Object.assign({}, this.cfg, cfg);\n\n        // Check if we have a kdf\n        if(config.format === undefined) {\n            throw new Error('missing format in config');\n        }\n\n        // Convert string to CipherParams\n        ciphertext = this._parse(ciphertext, config.format);\n\n        // Check if we have a kdf\n        if(config.kdf === undefined) {\n            throw new Error('the key derivation function must be set');\n        }\n\n        // Derive key and other params\n        const derivedParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n\n        // Check if we have an IV\n        if(derivedParams.iv !== undefined) {\n            // Add IV to config\n            config.iv = derivedParams.iv;\n        }\n\n        // Decrypt\n        const plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, config);\n\n        return plaintext;\n    }\n\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * @param ciphertext The ciphertext.\n     * @param format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return The unserialized ciphertext.\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     */\n    public static _parse(ciphertext: CipherParams | string, format: Formatter): CipherParams {\n        if(typeof ciphertext === 'string') {\n            return format.parse(ciphertext);\n        } else {\n            return ciphertext;\n        }\n    }\n}","import { BufferedBlockAlgorithm } from './BufferedBlockAlgorithm';\nimport { WordArray } from './WordArray';\nimport { SerializableCipher } from './SerializableCipher';\nimport { PasswordBasedCipher } from './PasswordBasedCipher';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { CipherParams } from './CipherParams';\n\nexport abstract class Cipher extends BufferedBlockAlgorithm {\n    /**\n     * A constant representing encryption mode.\n     */\n    public static _ENC_XFORM_MODE = 1;\n\n    /**\n     * A constant representing decryption mode.\n     */\n    public static _DEC_XFORM_MODE = 2;\n\n    /**\n     * This cipher's key size. Default: 4 (128 bits / 32 Bits)\n     */\n    public static keySize = 4;\n\n    /**\n     * This cipher's IV size. Default: 4 (128 bits / 32 Bits)\n     */\n    public static ivSize = 4;\n\n    /**\n     * Either the encryption or decryption transformation mode constant.\n     */\n    public _xformMode: number;\n\n    /**\n     * The key.\n     */\n    public _key: WordArray;\n\n    /**\n     * Creates this cipher in encryption mode.\n     *\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher instance.\n     *\n     * @example\n     *\n     *     let cipher = AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n     */\n    public static createEncryptor(key: WordArray, cfg?: BufferedBlockAlgorithmConfig): Cipher {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const thisClass: any = this;\n\n        return new thisClass(this._ENC_XFORM_MODE, key, cfg);\n    }\n\n    /**\n     * Creates this cipher in decryption mode.\n     *\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return A cipher instance.\n     *\n     * @example\n     *\n     *     let cipher = AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n     */\n    public static createDecryptor(key: WordArray, cfg?: BufferedBlockAlgorithmConfig): Cipher {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const thisClass: any = this;\n\n        return new thisClass(this._DEC_XFORM_MODE, key, cfg);\n    }\n\n    /**\n     * Creates shortcut functions to a cipher's object interface.\n     *\n     * @param cipher The cipher to create a helper for.\n     *\n     * @return An object with encrypt and decrypt shortcut functions.\n     *\n     * @example\n     *\n     *     let AES = Cipher._createHelper(AESAlgorithm);\n     */\n    public static _createHelper(cipher: typeof Cipher) {\n        function encrypt(message: WordArray | string, key: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\n            if(typeof key === 'string') {\n                return PasswordBasedCipher.encrypt(cipher, message, key, cfg);\n            } else {\n                return SerializableCipher.encrypt(cipher, message, key, cfg);\n            }\n        }\n\n        function decrypt(ciphertext: CipherParams | string, key: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\n            if(typeof key === 'string') {\n                return PasswordBasedCipher.decrypt(cipher, ciphertext, key, cfg);\n            } else {\n                return SerializableCipher.decrypt(cipher, ciphertext, key, cfg);\n            }\n        }\n\n        return {\n            encrypt: encrypt,\n            decrypt: decrypt\n        };\n    }\n\n    /**\n     * Initializes a newly created cipher.\n     *\n     * @param xformMode Either the encryption or decryption transormation mode constant.\n     * @param key The key.\n     * @param cfg (Optional) The configuration options to use for this operation.\n     *\n     * @example\n     *\n     *     let cipher = AES.create(AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n     */\n    public constructor(xformMode: number, key: WordArray, cfg?: BufferedBlockAlgorithmConfig) {\n        // Apply config defaults\n        super(Object.assign({\n            blockSize: 1\n        }, cfg));\n\n        // Store transform mode and key\n        this._xformMode = xformMode;\n        this._key = key;\n\n        // Set initial values\n        this.reset();\n    }\n\n    /**\n     * Adds data to be encrypted or decrypted.\n     *\n     * @param dataUpdate The data to encrypt or decrypt.\n     *\n     * @return The data after processing.\n     *\n     * @example\n     *\n     *     let encrypted = cipher.process('data');\n     *     let encrypted = cipher.process(wordArray);\n     */\n    public process(dataUpdate: WordArray | string): WordArray {\n        // Append\n        this._append(dataUpdate);\n\n        // Process available blocks\n        return this._process();\n    }\n\n    /**\n     * Finalizes the encryption or decryption process.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * @param dataUpdate The final data to encrypt or decrypt.\n     *\n     * @return The data after final processing.\n     *\n     * @example\n     *\n     *     var encrypted = cipher.finalize();\n     *     var encrypted = cipher.finalize('data');\n     *     var encrypted = cipher.finalize(wordArray);\n     */\n    public finalize(dataUpdate?: WordArray | string): WordArray {\n        // Final data update\n        if(dataUpdate) {\n            this._append(dataUpdate);\n        }\n\n        // Perform concrete-cipher logic\n        const finalProcessedData = this._doFinalize();\n\n        return finalProcessedData;\n    }\n\n    /**\n     * Cipher specific finalize function explicitly implemented in the derived class.\n     */\n    public abstract _doFinalize(): WordArray;\n}","import { BlockCipher } from '../lib/BlockCipher';\nimport { BlockCipherMode } from './BlockCipherMode';\n\nexport abstract class BlockCipherModeAlgorithm {\n    public _cipher!: BlockCipher;\n\n    public _iv: Array<number> | undefined;\n\n    public __creator: ((cipher: BlockCipher, iv: number[]) => BlockCipherMode) | undefined;\n\n    public constructor(cipher: BlockCipher, iv: Array<number>) {\n        this.init(cipher, iv);\n    }\n\n    /**\n     * Initializes a newly created mode.\n     *\n     * @param cipher A block cipher instance.\n     * @param iv The IV words.\n     *\n     * @example\n     *\n     *     var mode = CBC.Encryptor.create(cipher, iv.words);\n     */\n    public init(cipher: BlockCipher, iv?: Array<number>) {\n        this._cipher = cipher;\n        this._iv = iv;\n    }\n\n    public abstract processBlock(words: Array<number>, offset: number): void;\n}","import { BlockCipher } from '../lib/BlockCipher';\nimport { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport abstract class BlockCipherMode {\n    public static Encryptor: any = BlockCipherModeAlgorithm;\n\n    public static Decryptor: any = BlockCipherModeAlgorithm;\n\n    /**\n     * Creates this mode for encryption.\n     *\n     * @param cipher A block cipher instance.\n     * @param iv The IV words.\n     *\n     * @example\n     *\n     *     var mode = CBC.createEncryptor(cipher, iv.words);\n     */\n    public static createEncryptor(cipher: BlockCipher, iv: Array<number>): BlockCipherModeAlgorithm {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const encryptorClass: any = this.Encryptor;\n\n        return new encryptorClass(cipher, iv);\n    }\n\n    /**\n     * Creates this mode for decryption.\n     *\n     * @param cipher A block cipher instance.\n     * @param iv The IV words.\n     *\n     * @example\n     *\n     *     var mode = CBC.createDecryptor(cipher, iv.words);\n     */\n    public static createDecryptor(cipher: BlockCipher, iv: Array<number>): BlockCipherModeAlgorithm {\n        // workaround for typescript not being able to create a abstract creator function directly\n        const decryptorClass: any = this.Decryptor;\n\n        return new decryptorClass(cipher, iv);\n    }\n}","import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class CBCEncryptor extends BlockCipherModeAlgorithm {\n    public _prevBlock: Array<number> | undefined;\n\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        // Check if we have a blockSize\n        if(this._cipher.cfg.blockSize === undefined) {\n            throw new Error('missing blockSize in cipher config');\n        }\n\n        // XOR and encrypt\n        this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n        this._cipher.encryptBlock(words, offset);\n\n        // Remember this block to use with next block\n        this._prevBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n    }\n\n    public xorBlock(words: Array<number>, offset: number, blockSize: number) {\n        // Choose mixing block\n        let block;\n        if(this._iv) {\n            block = this._iv;\n\n            // Remove IV for subsequent blocks\n            this._iv = undefined;\n        } else {\n            block = this._prevBlock;\n        }\n\n        // block should never be undefined but we want to make typescript happy\n        if(block !== undefined) {\n            // XOR blocks\n            for(let i = 0; i < blockSize; i++) {\n                words[offset + i] ^= block[i];\n            }\n        }\n    }\n}","import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class CBCDecryptor extends BlockCipherModeAlgorithm {\n    public _prevBlock: Array<number> | undefined;\n\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        // Check if we have a blockSize\n        if(this._cipher.cfg.blockSize === undefined) {\n            throw new Error('missing blockSize in cipher config');\n        }\n\n        // Remember this block to use with next block\n        const thisBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n\n        // Decrypt and XOR\n        this._cipher.decryptBlock(words, offset);\n        this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n\n        // This block becomes the previous block\n        this._prevBlock = thisBlock;\n    }\n\n    public xorBlock(words: Array<number>, offset: number, blockSize: number) {\n        // Choose mixing block\n        let block;\n        if(this._iv) {\n            block = this._iv;\n\n            // Remove IV for subsequent blocks\n            this._iv = undefined;\n        } else {\n            block = this._prevBlock;\n        }\n\n        // block should never be undefined but we want to make typescript happy\n        if(block !== undefined) {\n            // XOR blocks\n            for(let i = 0; i < blockSize; i++) {\n                words[offset + i] ^= block[i];\n            }\n        }\n    }\n}","import { BlockCipherMode } from './BlockCipherMode';\nimport { CBCEncryptor } from './CBCEncryptor';\nimport { CBCDecryptor } from './CBCDecryptor';\n\n/**\n * Cipher Block Chaining mode.\n */\nexport abstract class CBC extends BlockCipherMode {\n    public static Encryptor: any = CBCEncryptor;\n\n    public static Decryptor: any = CBCDecryptor;\n}","import { WordArray } from '../lib/WordArray';\nimport { Padding } from '../pad/Padding';\n\nexport class PKCS7 {\n    /**\n     * Pads data using the algorithm defined in PKCS #5/7.\n     *\n     * @param data The data to pad.\n     * @param blockSize The multiple that the data should be padded to.\n     *\n     * @example\n     *\n     *     PKCS7.pad(wordArray, 4);\n     */\n    public static pad(data: WordArray, blockSize: number): void {\n        // Shortcut\n        const blockSizeBytes = blockSize * 4;\n\n        // Count padding bytes\n        const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n        // Create padding word\n        const paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n        // Create padding\n        const paddingWords = [];\n        for (let i = 0; i < nPaddingBytes; i += 4) {\n            paddingWords.push(paddingWord);\n        }\n        const padding = new WordArray(paddingWords, nPaddingBytes);\n\n        // Add padding\n        data.concat(padding);\n    }\n\n    /**\n     * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n     *\n     * @param data The data to unpad.\n     *\n     * @example\n     *\n     *     PKCS7.unpad(wordArray);\n     */\n    public static unpad(data: WordArray): void {\n        // Get number of padding bytes from last byte\n        const nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n        // Remove padding\n        data.sigBytes -= nPaddingBytes;\n    }\n}\n\n// type guard for the formatter (to ensure it has the required static methods)\nconst _: Padding = PKCS7;","import { Cipher } from './Cipher';\nimport { WordArray } from './WordArray';\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\nimport { BlockCipherModeAlgorithm } from '../mode/BlockCipherModeAlgorithm';\nimport { CBC } from '../mode/CBC';\nimport { PKCS7 } from '../pad/PKCS7';\n\nexport abstract class BlockCipher extends Cipher {\n    public _mode!: BlockCipherModeAlgorithm;\n\n    constructor(xformMode: number, key: WordArray, cfg?: BufferedBlockAlgorithmConfig) {\n        super(xformMode, key, Object.assign({\n            // default: 128 / 32\n            blockSize: 4,\n            mode: CBC,\n            padding: PKCS7\n        }, cfg));\n    }\n\n    public reset() {\n        // Reset cipher\n        super.reset();\n\n        // Check if we have a blockSize\n        if(this.cfg.mode === undefined) {\n            throw new Error('missing mode in config');\n        }\n\n        // Reset block mode\n        let modeCreator;\n        if (this._xformMode === (<typeof BlockCipher> this.constructor)._ENC_XFORM_MODE) {\n            modeCreator = this.cfg.mode.createEncryptor;\n        } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n            modeCreator = this.cfg.mode.createDecryptor;\n            // Keep at least one block in the buffer for unpadding\n            this._minBufferSize = 1;\n        }\n\n        if (this._mode && this._mode.__creator === modeCreator) {\n            this._mode.init(this, this.cfg.iv && this.cfg.iv.words);\n        } else {\n            this._mode = modeCreator.call(this.cfg.mode, this, this.cfg.iv && this.cfg.iv.words);\n            this._mode.__creator = modeCreator;\n        }\n    }\n\n    _doProcessBlock(words: Array<number>, offset: number) {\n        this._mode.processBlock(words, offset);\n    }\n\n    _doFinalize() {\n        // Check if we have a padding strategy\n        if(this.cfg.padding === undefined) {\n            throw new Error('missing padding in config');\n        }\n\n        // Finalize\n        let finalProcessedBlocks;\n        if(this._xformMode === (<typeof BlockCipher> this.constructor)._ENC_XFORM_MODE) {\n            // Check if we have a blockSize\n            if(this.cfg.blockSize === undefined) {\n                throw new Error('missing blockSize in config');\n            }\n\n            // Pad data\n            this.cfg.padding.pad(this._data, this.cfg.blockSize);\n\n            // Process final blocks\n            finalProcessedBlocks = this._process(!!'flush');\n        } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n            // Process final blocks\n            finalProcessedBlocks = this._process(!!'flush');\n\n            // Unpad data\n            this.cfg.padding.unpad(finalProcessedBlocks);\n        }\n\n        return finalProcessedBlocks;\n    }\n\n    public abstract encryptBlock(M: Array<number>, offset: number): void;\n\n    public abstract decryptBlock(M: Array<number>, offset: number): void;\n}","import { BlockCipher } from '../lib/BlockCipher';\nimport { WordArray } from '../lib/WordArray';\nimport { BufferedBlockAlgorithmConfig } from '../lib/BufferedBlockAlgorithmConfig';\n\n// Define lookup tables\nconst SBOX: Array<number> = [];\nconst INV_SBOX: Array<number> = [];\nconst SUB_MIX_0: Array<number> = [];\nconst SUB_MIX_1: Array<number> = [];\nconst SUB_MIX_2: Array<number> = [];\nconst SUB_MIX_3: Array<number> = [];\nconst INV_SUB_MIX_0: Array<number> = [];\nconst INV_SUB_MIX_1: Array<number> = [];\nconst INV_SUB_MIX_2: Array<number> = [];\nconst INV_SUB_MIX_3: Array<number> = [];\n\n// Compute lookup tables\n(function () {\n    // Compute double table\n    const d = [];\n    for (let i = 0; i < 256; i++) {\n        if (i < 128) {\n            d[i] = i << 1;\n        } else {\n            d[i] = (i << 1) ^ 0x11b;\n        }\n    }\n\n    // Walk GF(2^8)\n    let x = 0;\n    let xi = 0;\n    for (let i = 0; i < 256; i++) {\n        // Compute sbox\n        let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n        SBOX[x] = sx;\n        INV_SBOX[sx] = x;\n\n        // Compute multiplication\n        const x2 = d[x];\n        const x4 = d[x2];\n        const x8 = d[x4];\n\n        // Compute sub bytes, mix columns tables\n        let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n        SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n        SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n        SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\n        SUB_MIX_3[x] = t;\n\n        // Compute inv sub bytes, inv mix columns tables\n        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n        INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n        INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n        INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\n        INV_SUB_MIX_3[sx] = t;\n\n        // Compute next counter\n        if (!x) {\n            x = xi = 1;\n        } else {\n            x = x2 ^ d[d[d[x8 ^ x2]]];\n            xi ^= d[d[xi]];\n        }\n    }\n}());\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\nexport class AES extends BlockCipher {\n    // 256 / 32\n    public static keySize = 8;\n\n    _nRounds!: number;\n\n    _key!: WordArray;\n\n    _keyPriorReset!: WordArray;\n\n    _keySchedule!: Array<number>;\n\n    _invKeySchedule!: Array<number>;\n\n    constructor(xformMode: number, key: WordArray, cfg?: BufferedBlockAlgorithmConfig) {\n        super(xformMode, key, cfg);\n    }\n\n    reset() {\n        // reset core values\n        super.reset();\n\n        // Skip reset of nRounds has been set before and key did not change\n        if (this._nRounds && this._keyPriorReset === this._key) {\n            return;\n        }\n\n        // Shortcuts\n        const key = this._keyPriorReset = this._key;\n        const keyWords = key.words;\n        const keySize = key.sigBytes / 4;\n\n        // Compute number of rounds\n        const nRounds = this._nRounds = keySize + 6;\n\n        // Compute number of key schedule rows\n        const ksRows = (nRounds + 1) * 4;\n\n        // Compute key schedule\n        const keySchedule: Array<number> = this._keySchedule = [];\n        for (let ksRow = 0; ksRow < ksRows; ksRow++) {\n            if (ksRow < keySize) {\n                keySchedule[ksRow] = keyWords[ksRow];\n            } else {\n                let t = keySchedule[ksRow - 1];\n\n                if (!(ksRow % keySize)) {\n                    // Rot word\n                    t = (t << 8) | (t >>> 24);\n\n                    // Sub word\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\n                    // Mix Rcon\n                    t ^= RCON[(ksRow / keySize) | 0] << 24;\n                } else if (keySize > 6 && ksRow % keySize === 4) {\n                    // Sub word\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n                }\n\n                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n            }\n        }\n\n        // Compute inv key schedule\n        const invKeySchedule: Array<number> = this._invKeySchedule = [];\n        for (let invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n            const ksRow = ksRows - invKsRow;\n\n            let t;\n            if (invKsRow % 4) {\n                t = keySchedule[ksRow];\n            } else {\n                t = keySchedule[ksRow - 4];\n            }\n\n            if (invKsRow < 4 || ksRow <= 4) {\n                invKeySchedule[invKsRow] = t;\n            } else {\n                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n                                           INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n            }\n        }\n    }\n\n    encryptBlock(M: Array<number>, offset: number) {\n        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n    }\n\n    decryptBlock(M: Array<number>, offset: number) {\n        // Swap 2nd and 4th rows\n        let t = M[offset + 1];\n        M[offset + 1] = M[offset + 3];\n        M[offset + 3] = t;\n\n        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n        // Inv swap 2nd and 4th rows\n        t = M[offset + 1];\n        M[offset + 1] = M[offset + 3];\n        M[offset + 3] = t;\n    }\n\n    _doCryptBlock(\n        M: Array<number>,\n        offset: number,\n        keySchedule: Array<number>,\n        sub_mix_0: Array<number>,\n        sub_mix_1: Array<number>,\n        sub_mix_2: Array<number>,\n        sub_mix_3: Array<number>,\n        sbox: Array<number>\n    ) {\n        // Get input, add round key\n        let s0 = M[offset]     ^ keySchedule[0];\n        let s1 = M[offset + 1] ^ keySchedule[1];\n        let s2 = M[offset + 2] ^ keySchedule[2];\n        let s3 = M[offset + 3] ^ keySchedule[3];\n\n        // Key schedule row counter\n        let ksRow = 4;\n\n        // Rounds\n        for (let round = 1; round < this._nRounds; round++) {\n            // Shift rows, sub bytes, mix columns, add round key\n            const t0 = sub_mix_0[s0 >>> 24] ^ sub_mix_1[(s1 >>> 16) & 0xff] ^ sub_mix_2[(s2 >>> 8) & 0xff] ^ sub_mix_3[s3 & 0xff] ^\n                     keySchedule[ksRow++];\n            const t1 = sub_mix_0[s1 >>> 24] ^ sub_mix_1[(s2 >>> 16) & 0xff] ^ sub_mix_2[(s3 >>> 8) & 0xff] ^ sub_mix_3[s0 & 0xff] ^\n                     keySchedule[ksRow++];\n            const t2 = sub_mix_0[s2 >>> 24] ^ sub_mix_1[(s3 >>> 16) & 0xff] ^ sub_mix_2[(s0 >>> 8) & 0xff] ^ sub_mix_3[s1 & 0xff] ^\n                     keySchedule[ksRow++];\n            const t3 = sub_mix_0[s3 >>> 24] ^ sub_mix_1[(s0 >>> 16) & 0xff] ^ sub_mix_2[(s1 >>> 8) & 0xff] ^ sub_mix_3[s2 & 0xff] ^\n                     keySchedule[ksRow++];\n\n            // Update state\n            s0 = t0;\n            s1 = t1;\n            s2 = t2;\n            s3 = t3;\n        }\n\n        // Shift rows, sub bytes, add round key\n        const t0g = ((sbox[s0 >>> 24] << 24) | (sbox[(s1 >>> 16) & 0xff] << 16) | (sbox[(s2 >>> 8) & 0xff] << 8) | sbox[s3 & 0xff]) ^\n                    keySchedule[ksRow++];\n        const t1g = ((sbox[s1 >>> 24] << 24) | (sbox[(s2 >>> 16) & 0xff] << 16) | (sbox[(s3 >>> 8) & 0xff] << 8) | sbox[s0 & 0xff]) ^\n                    keySchedule[ksRow++];\n        const t2g = ((sbox[s2 >>> 24] << 24) | (sbox[(s3 >>> 16) & 0xff] << 16) | (sbox[(s0 >>> 8) & 0xff] << 8) | sbox[s1 & 0xff]) ^\n                    keySchedule[ksRow++];\n        const t3g = ((sbox[s3 >>> 24] << 24) | (sbox[(s0 >>> 16) & 0xff] << 16) | (sbox[(s1 >>> 8) & 0xff] << 8) | sbox[s2 & 0xff]) ^\n                    keySchedule[ksRow++];\n\n        // Set output\n        M[offset]     = t0g;\n        M[offset + 1] = t1g;\n        M[offset + 2] = t2g;\n        M[offset + 3] = t3g;\n    }\n}","import { Hasher } from '../lib/Hasher';\nimport { WordArray } from '../lib/WordArray';\n\n// Initialization and round constants tables\nconst H: Array<number> = [];\nconst K: Array<number> = [];\n\n// Reusable object\nconst W: Array<number> = [];\n\nexport class SHA256 extends Hasher {\n    public _hash!: WordArray;\n\n    public reset() {\n        // reset core values\n        super.reset();\n\n        this._hash = new WordArray(H.slice(0));\n    }\n\n    public _doProcessBlock(M: Array<number>, offset: number) {\n        // Shortcut\n        const Hl = this._hash.words;\n\n        // Working variables\n        let a = Hl[0];\n        let b = Hl[1];\n        let c = Hl[2];\n        let d = Hl[3];\n        let e = Hl[4];\n        let f = Hl[5];\n        let g = Hl[6];\n        let h = Hl[7];\n\n        // Computation\n        for(let i = 0; i < 64; i++) {\n            if(i < 16) {\n                W[i] = M[offset + i] | 0;\n            } else {\n                const gamma0x = W[i - 15];\n                const gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n                              ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                               (gamma0x >>> 3);\n\n                const gamma1x = W[i - 2];\n                const gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                              ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                               (gamma1x >>> 10);\n\n                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n            }\n\n            const ch  = (e & f) ^ (~e & g);\n            const maj = (a & b) ^ (a & c) ^ (b & c);\n\n            const sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n            const sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n            const t1 = h + sigma1 + ch + K[i] + W[i];\n            const t2 = sigma0 + maj;\n\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n\n        // Intermediate hash value\n        Hl[0] = (Hl[0] + a) | 0;\n        Hl[1] = (Hl[1] + b) | 0;\n        Hl[2] = (Hl[2] + c) | 0;\n        Hl[3] = (Hl[3] + d) | 0;\n        Hl[4] = (Hl[4] + e) | 0;\n        Hl[5] = (Hl[5] + f) | 0;\n        Hl[6] = (Hl[6] + g) | 0;\n        Hl[7] = (Hl[7] + h) | 0;\n    }\n\n    public _doFinalize(): WordArray {\n        const nBitsTotal = this._nDataBytes * 8;\n        const nBitsLeft = this._data.sigBytes * 8;\n\n        // Add padding\n        this._data.words[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n        this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n        this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n        this._data.sigBytes = this._data.words.length * 4;\n\n        // Hash final blocks\n        this._process();\n\n        // Return final computed hash\n        return this._hash;\n    }\n}","import { WordArray } from '../lib/WordArray';\nimport { Padding } from '../pad/Padding';\n\nexport class NoPadding {\n    /**\n     * Doesn't pad the data provided.\n     *\n     * @param data The data to pad.\n     * @param blockSize The multiple that the data should be padded to.\n     *\n     * @example\n     *\n     *     NoPadding.pad(wordArray, 4);\n     */\n    public static pad(data: WordArray, blockSize: number): void {\n    }\n\n    /**\n     * Doesn't unpad the data provided.\n     *\n     * @param data The data to unpad.\n     *\n     * @example\n     *\n     *     NoPadding.unpad(wordArray);\n     */\n    public static unpad(data: WordArray): void {\n    }\n}\n\n// type guard for the padding (to ensure it has the required static methods)\nconst _: Padding = NoPadding;","import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class ECBEncryptor extends BlockCipherModeAlgorithm {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        this._cipher.encryptBlock(words, offset);\n    }\n}","import { BlockCipherModeAlgorithm } from './BlockCipherModeAlgorithm';\n\nexport class ECBDecryptor extends BlockCipherModeAlgorithm {\n    /**\n     * Processes the data block at offset.\n     *\n     * @param words The data words to operate on.\n     * @param offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    public processBlock(words: Array<number>, offset: number) {\n        this._cipher.decryptBlock(words, offset);\n    }\n}","import { BlockCipherMode } from './BlockCipherMode';\nimport { ECBEncryptor } from './ECBEncryptor';\nimport { ECBDecryptor } from './ECBDecryptor';\n\n/**\n * Cipher Block Chaining mode.\n */\nexport abstract class ECB extends BlockCipherMode {\n    public static Encryptor: typeof ECBEncryptor = ECBEncryptor;\n\n    public static Decryptor: typeof ECBDecryptor = ECBDecryptor;\n}","// DEPENDENCIES ////////////////////////////////////////////////////////////////////////////////////\n\n// import indirectly referenced declarations\nimport { BufferedBlockAlgorithmConfig } from './lib/BufferedBlockAlgorithmConfig';\n\n// LIB /////////////////////////////////////////////////////////////////////////////////////////////\n\nimport { WordArray } from './lib/WordArray';\nimport { BlockCipher } from './lib/BlockCipher';\nimport { CipherParams } from './lib/CipherParams';\nimport { Hasher } from './lib/Hasher';\nimport { SerializableCipher } from './lib/SerializableCipher';\nimport { PasswordBasedCipher } from './lib/PasswordBasedCipher';\n\nexport const lib = {\n    BlockCipher: BlockCipher,\n    WordArray: WordArray,\n    CipherParams: CipherParams,\n    Hasher: Hasher,\n    SerializableCipher: SerializableCipher,\n    PasswordBasedCipher: PasswordBasedCipher\n};\n\n// ALGORITHMS //////////////////////////////////////////////////////////////////////////////////////\n\nimport { AES as AESAlgorithm } from './algo/AES';\nimport { SHA256 as SHA256Algorithm } from './algo/SHA256';\n\nexport const algo = {\n    AES: AESAlgorithm,\n    SHA256: SHA256Algorithm\n};\n\n// ENCODINGS ///////////////////////////////////////////////////////////////////////////////////////\n\nimport { Utf8 } from './enc/Utf8';\nimport { Hex } from './enc/Hex';\n\nexport const enc = {\n    Utf8: Utf8,\n    Hex: Hex\n};\n\n// PADDING /////////////////////////////////////////////////////////////////////////////////////////\n\nimport { NoPadding } from './pad/NoPadding';\nimport { PKCS7 } from './pad/PKCS7';\n\nexport const pad = {\n    NoPadding: NoPadding,\n    PKCS7: PKCS7\n};\n\n// MODES ///////////////////////////////////////////////////////////////////////////////////////////\n\nimport { CBC } from './mode/CBC';\nimport { ECB } from './mode/ECB';\n\nexport const mode = {\n    CBC: CBC,\n    ECB: ECB\n};\n\n// HELPERS /////////////////////////////////////////////////////////////////////////////////////////\n\nexport const AES = lib.BlockCipher._createHelper(algo.AES);\nexport const SHA256 = lib.Hasher._createHelper(algo.SHA256);"]}